
#!/bin/bash
#globals
matcol=0
matrow=0
#validate the input. check the functions that are suppose to only get on argument
if [ $1 = "dims" ] || [ $1 = "transpose" ] || [ $1 = "mean" ]
then
    if [ $# -gt 2 ]
    then
        echo "Too many arguments" >&2
        echo "Too many arguments"
        exit 1
    fi
 #if we have correct amount check if the argument is able to be read   
    if [ "$#" -eq "2" ]
    then
        if [ ! -r "$2" ]
        then
            echo "The file can not be read" >&2
        fi  
    fi
#check the other functions are getting the proper amount of arguments
elif [ $2 = "add" ] || [ $2 = "multiply" ]
then
    if [ $# -gt 3 ]
    then
        echo "Too many arguments" >&2
        echo "Too many arguments"
        exit 1
    fi
# validates that each argument is readable    
    if [ "$#" -eq "3" ]
    then
        if [ ! -r "$3" ]
        then
            echo "The file can not be read" >&2
        fi  
    fi
    if [ "$#" -eq "4" ]
    then
        if [ ! -r "$4" ]
        then
            echo "The file can not be read" >&2
        fi  
    fi
fi
#dim should print the dimensions of the matrix as the number of rows, followed
#by a space , then the number of columns

function dims(){
  
    printf "Dims function\n"
    #variables that will hold the count of rows and cols through the loop but will be reset to zero and
    #the totals will be in the globals
    numcol=0 
    numrow=0
    #tempfiles that will be deleted upon completion of the function
    inputFile="tempfile"
    colfile="tempcol"
    rowfile="temprow"
    dimsout="tempdims"
    echo "arg" $2
    echo "arg1" $1
    echo "0" $#   
    
    while read line
    do     
    for i in $line #get total cols
        do 
        numcol=$(($numcol + 1))
        echo "Col" $numcol
    done
    if [ $matcol -eq 0 ] #check if the global is set to zero, if so set to the our for count 
        then
        matcol=$numcol
    elif [ $numcol -ne $matcol ] #this checks if the globals and locals are equal if they arent then the matrix is set up correctly
        then
        echo "error"
        exit 1
    fi
    numcol=0 #reset the local to count the next col
    matrow=$(($matrow + 1))  #count the number of rows
    echo "row" $matrow 
    
    done <$1
    # pass each count to a file
    echo $matcol > $colfile 
    echo $matrow > $rowfile
    # pass the total results to the final file
    echo "ROWS: $matrow COLS: $matcol" > $dimsout
    echo "ROWS: $matrow COLS: $matcol" 
    rm $colfile $rowfile #remove the files
    
    return 0
}
#dims $2

#transpose should reflect the elements of the matrix along the main diagonal.
# thus, an MxN matrix will become an NxM matrix and the values along the main
# diagonal will remain unchanged

function transpose(){
    dims $1 # call the dims function to set the rows and cols
    #set up the variables to the temp files
    inputFile="tempfile"
    colfile="tempcol"
    rowfile="temprow"
    # send the matrix to a file
    cat $1 > $inputFile
    read rowone < $inputFile #get the 1st rows data
    echo $inputFile $matcol $matrow $1 $rowone
    echo " "
    for((j=1; j<=matcol;j++))
    do
        cut -f $j $inputFile >$colfile #cut 
        cat $colfile | tr '\n' '\t' >>$rowfile # trade all newlines with a tab and add it to the rowfile
        echo >>$rowfile
    done

    while read line
    do
        echo $line
    done < $rowfile

    rm $inputFile $colfile $rowfile #clean up temp files
}
#transpose $2

# mean should take an MxN matrix and return an 1xN row vector, where the first
# element is the mean of column one, the second element is the mean of 
# column 2, and so on

function mean(){
    dims $1 # call the dims function to set the rows and cols
    #set variables to zero and variable to temp files
    sum=0
    matmean=0
    newcol=0
    rowsum=0
    colfile="tempcol"
    rowfile="temprow"
    sumfile="tempsum"
    inputFile="tempfile"
    meanfile="tempmean"
    finaloutput="tempfinal"
    cat $1 > $inputFile #get the matrix and put in a file
    for((j=1;j<=$matcol;j++))
     do
        newcol=$(cut -f"$j" $inputFile) #cut a number form the input file and set to a variable
        printf "%s\n" "$newcol" > $colfile #send the variable to the colfile
        echo "NewCol $newcol"
        #sum=0
        while read newrow
            do
                sum=$(($sum+$newrow)) #adds each value to get a sum
                #echo "NewRow" $newrow
                #echo "Sum $sum"
                #sum >> $sumfile
            done < $colfile
            echo "Sum $sum"
            rowsum=$sum
            printf "%s\t" $rowsum >> $sumfile #prints results to a file to hold sums
            sum=0
            #echo "SUm2" $sum
     done

    for((i=1;i<=$matcol;i++))
        do
            newmean=$(cut -f"$i" $sumfile) #get the sum and sets to be used for the mean
            printf "%s\n" "$newmean" > $meanfile # prints to the meanfile
            while read mean
                do
                    mean=$(( ($mean+($matcol/2)*( ($mean >0)*2-1)) /$matcol)) #figures the mean and rounds up to the next number if greater then .5
                    echo "Mean" $mean
                    colmean=$mean
                    printf "%s\t" $colmean >> $finaloutput #prints the mean to the finished file
                    #cat $meanfile
                done < $meanfile
            mean=0 #reset mean back to zero to run it again
        done
     
     #rm $inputFile $colfile $meanfile $sumfile #clean up files
}
#mean $2


# add should take 2 MxN matrices and add them together element-wise to produce
# an MxN matrix. add should return an error if the matrices do not have the same
# dimensions
function add(){
    # call dims and send to a file
    dims $1 > mat1mxn
    echo $matcol $matrow > comparemat # send the results the column and rows to a new file
    matcol=0 #reset globals to test matrix size with dims on it
    matrow=0
    dims $2 > mat2mxn #gets the rows and column of the second matrix
    echo $matcol $matrow > comparemat2

    if cmp -s comparemat comparemat2 #compare the results of the 2 dims to check if they have the same rows and cols
    then
        echo "matrixs are the same mxn"
    else
        echo "Not the same mxn"
    fi
    # set the variables for files and sum
    sum=0 
    inputfile1="tempfile1"
    inputfile2="tempfile2"
    newmat1="tempmat1"
    newmat2="tempmat2"
    outfile="tempout"
    row1="temprow1"
    row2="temprow2"
    # send the arguments to files to add
    cat "$1" > $inputfile1
    cat "$2" > $inputfile2
    touch $outfile
    touch $row1
    

    while read matrix1 && read matrix2 <&3    # read each line of each matrix
        do
            echo "In"
            echo "mat1" $matrix1
            echo "mat2" $matrix2
            echo -e "$matrix1" > $row1 # sends the read values to a file
            echo -e "$matrix2" > $row2
            j=1
            for number in $matrix1
            do
                #printf "%s\t" "$matrix1" > $row1 #print each value to the row
                num1=$(cut -f $j $row1) #cut the results and set to a variable
                echo "row1" $row1 
                #printf "%s\t" "$matrix2" > $row2
                num2=$(cut -f $j $row2)
                sum=$(($num1+$num2)) # add both values and get the sum 
                echo "Sum" $sum
                printf "%s\t" "$sum" >> $outfile # print the sums to a file
                j=$(($j+1)) #increment j
            done
            echo >>$outfile #send results to final file
        done < $inputfile1 3<$inputfile2    
        #rm $inputFile $colfile $meanfile $sumfile #clean up files
}
#add $2 $3

# multiply should take an MxN and NxP matrix produce an MxP matrix. Mote that, unlike
# addition matrix multiplication is not commutative. That is A*B != B*A
function multiply(){
     # call dims and send to a file
    dims $1 > mat1mxn
    echo $matrow > comparemat # send the results the column and rows to a new file
    matcol=0 #reset globals to test matrix size with dims on it
    matrow=0
    dims $2 > mat2mxn #gets the rows and column of the second matrix
    echo $matcol > comparemat2

    if cmp -s comparemat comparemat2 #compare the results of the 2 dims to check if they have the same rows and cols
    then
        echo "matrixs have the same n"
    else
        echo "Not dont have the same n"

    #set variables for the product and the temp files    
    product=0
    inputfile1="tempfile1"
    inputfile2="tempfile2"
    newmat1="tempmat1"
    newmat2="tempmat2"
    outfile="tempout"
    row1="temprow1"
    row2="temprow2"
    # send arguments to independent files
    cat "$1" > $inputfile1
    cat "$2" > $inputfile2
    touch $outfile #create a file for the final output
    touch $row1
 while read matrix1 && read matrix2 <&3    
        do
            echo "In"
            echo "mat1" $matrix1
            echo "mat2" $matrix2
            echo -e "$matrix1" > $row1
            echo -e "$matrix2" > $row2
            j=1
            for number in $matrix1
            do
                #printf "%s\t" "$matrix1" > $row1
                num1=$(cut -f $j $row1)
                echo "row1" $row1 
                #printf "%s\t" "$matrix2" > $row2
                num2=$(cut -f $j $row2)
                product=$(($num1*$num2))
                echo "product" $product
                printf "%s\t" "$product" >> $outfile 
                j=$(($j+1))
            done
            echo >>$outfile
        done < $inputfile1 3<$inputfile2    
}

multiply $2 $3
